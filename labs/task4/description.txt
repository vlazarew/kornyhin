1. Реализация
    Поиск/добавление/удаление ключа в ассоциативном массиве реализован как описано в Варианте В (хеш-таблица с
    линейным пробированием).

    Используется цикл по хеш-таблице, внутри которого вычисляется индекс ячейки. Это все последствия линейного пробирования.

    1.1. Добавление
        Если попытаться добавить элемент с тем же ключом, то ничего не выйдет. По условию уточняется, что таблица может
        содержать только одно отображение. При попытке повторного добавления значения с таким же ключом будет
        код возврата - 0.
        При выявлении такого индекса ячейки, что existent != 1, в нее записывается key/value пара.
        Если ячеек с existent == 0 не найдено, выбрасываем 0, в случае успеха - 1.

    1.2. Удаление
        В самом начале на основе хеша ключа рассчитывается первый потенциальный индекс ячейки. Если по этой ячейке existent == 1 и ключ совпадает,
        то запись помечается как existent = 0, count уменьшается, ячейка становится доступна для записи. Если по заданному индексу нет такой ячейки,
        то проходим по всей таблице в поисках ее. В случае, если не найдено выбрасываем 0, в случае успеха - 1.


    1.3. Получение
        Если existent ячейки == 1 и ключи идентичные, то в value передается значение ячейки, код возврата - 1.
        В случае полного прохода по циклу (ячейка с данным идексом + ключом не найдена) код возврата - 0.


2. Тестирование
    2.1. Статический анализ
         * Clang ('scan-build clang --analyze map.c',
                 'scan-build clang -fsanitize=address map.c')
         * Splint ('{PATH_TO_SPLINT_BINARY} -weak map.c')
         * Cppcheck ('cppcheck map.c')
    2.2. Динамический анализ
        * Valgrind

    2.3. Файл с тестами - tests.c