module Graph

use import int.Int
use import ref.Ref
use import map.Map

type vertex = {payload: int; existent: int}
type edge   = {from: int; to: int; existent: int}
type graph  = {vertices: map (vertex); vsize: int; edges: map (edge); ecnt: int; esize: int}


predicate is_vertex (g: graph) (v: int) = 0 <= v < !g.vsize

predicate edge_valid (g:graph) (k: int) = is_existent (get_edge !g.edges k) -> 
    is_vertex g (get_from (get_edge !g.edges k)) /\ is_vertex g (get_to (get_edge !g.edges k))
    is_existent (get_vertices (get_from (get_edge !g.edges k))) /\ is_existent (get_vertices (get_to (get_edge !g.edges k)))

predicate edges_valid (g: graph) (n: int) = forall k: int. 0 <= k < n -> edge_valid g k

(* TODO: а как тут передать мне диапазон значений? *)
predicate graph_valid (g: graph) = !g.vsize > 0 /\ !g.esize > 0 /\ !g.esize >= !g.ecnt >= 0 /\
    valid (!g.vertices + 1) /\
    valid (!g.edges + 1 ) /\
    edges_valid g !g.ecnt /\
    forall k: int. !g.ecnt <= k < !g.esize -> not is_existent (get_edge !g.edges k)

predicate full (g: graph) = range_existent g 0 !g.esize
predicate range_existent (g: graph) (m n: int) = forall k: int. m <= k < n -> is_existent (get_edge !g.edges k)


(* axiom edgesCount  *)
(* TODO: Вот и как мне теперь это в why3 перевести *)
(*     logic integer count{L}(Graph *g, integer f, integer t, integer m, integer n); *)
(* logic integer all_count(Graph *g, integer f, integer t) = count(g, f, t, 0, g->esize); *)

axiom count_zero = forall g: graph; f, t, m, n: int. m >= n -> count g f t m n == 0
predicate count_one_p (g: graph) (f t m: int) = count g f t m (m + 1) ==  
    (is_existent (get_edge !g.edges m) /\ 
    get_from (get_edge !g.edges m) == f /\
    get_to (get_edge !g.edges m) == t)

axiom count_one = forall g: graph; f t m: int. count_one_p g f t m

predicate count_split_p (g: graph) (f t m n k: int) = count g f t m k == (count f g t m n + count g f t n k)

axiom count_split = forall g: Graph; f t m n k: int. m <= n <= k -> count_split_p g f t m n k

let count (graph: ref (graph)) (from: int) (to: int): int
    requires {valid graph /\ graph_valid graph}
    requires {is_vertex graph from}
    requires {is_vertex graph to}
    requires {is_existent !graph.vertices from}
    requires {is_existent !graph.vertices to}
    ensures  {result == all_count graph from to} 
=
    let c = 0 in
        let i = 0 in
            while (i < !graph.ecnt) do
                if (is_existent !g.edges i /\ get_from !g.edges i == from /\ get_to !g.edges i == to) then
                    c <- c + 1;
            done;
        return c

(* TODO Доделать саму функцию *)
let add_edge (graph: ref (graph)) (from: int) (to: int): unit
    requires {valid graph /\ graph_valid graph}
    requires {is_vertex graph from}
    requires {is_vertex graph to}
    requires {is_existent !graph.vertices from}
    requires {is_existent !graph.vertices to}
    requires {not full graph}
    ensures  {graph_valid graph}
    ensures  {all_count graph from to == ((at all_count graph from to 'Pre) + 1)}
    ensures  {forall f2, t2: int. (f2 != from \/ t2 != to) -> all_count graph f2 t2 == (at all_count graph from to 'Pre)}
=
    if (!graph.ecnt < !graph.esize) then
        get_from !graph.ecnt <- from
        get_to !graph.ecnt <- to
        get_existent <- 1

    let i = 0 in
        while (i < graph.ecnt) do
            if (not !graph.)
        
        done





end