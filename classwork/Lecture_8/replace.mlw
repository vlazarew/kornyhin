module Replace

use import int.Int
use import ref.Ref

type block_id 't
type pointer 't = {blkid: block_id 't; offset: int}
type memory 't (* Отображение pointer -> value *)
type alloc_table 't (* Отображение block_id -> int *)

function select(mem: memory 't) (arr: pointer 't): 't
function shift(arr: pointer 't) (offset: int): pointer 't
function store (mem: ref (memory 't)) ( arr: pointer 't ) ( value : 't ) : unit 

function get_value (block_sizes: alloc_table 't) (blkid: block_id 't): int

predicate valid (p: pointer 't) (mem: (memory 't)) (block_sizes: alloc_table 't) = 
    (0 <= p.offset < (get_value block_sizes p.blkid))

predicate same_block (p1 p2: pointer 't) = p1.blkid = p2.blkid

axiom shift_func: forall p: pointer 't, shift_offset: int. 
	(shift p shift_offset).offset = p.offset + shift_offset /\
	same_block (shift p shift_offset) p

val acc_safe (mem: memory 't) (block_sizes: alloc_table 't) ( p: pointer 't ): 't
requires { valid p mem block_sizes }
ensures { select mem p = result }

val shift_safe ( p: pointer 't) (shift_offset: int): pointer 't
ensures { shift p shift_offset = result }

val subs_safe ( p1 p2: pointer 't): int
requires { same_block p1 p2 }
ensures { p1 = shift p2 result }

val upd_safe (mem: ref (memory 't)) (block_sizes: alloc_table 't) ( p: pointer 't ) ( value : 't ) : unit
requires { valid p !mem block_sizes }
ensures { select !mem p = value }



let replace (mem: ref (memory 't)) (block_sizes: alloc_table 't) (arr: pointer 't) (size: int) (a b: 't):unit
    requires {size >= 0}
    requires {forall ind. 0 <= ind < size -> valid (shift arr ind) !mem block_sizes}
    ensures {forall ind. 0 <= ind < size /\ select (old !mem) (shift arr ind) = a -> select !mem (shift arr ind) = b}
    ensures {forall ind. 0 <= ind < size /\ select (old !mem) (shift arr ind) <> a -> select !mem (shift arr ind) = select (old !mem) (shift arr ind)}
=
'Pre:
    let p = ref arr in
        while ((subs_safe !p arr) < size) do
        invariant { 0 <= (!p.offset - arr.offset) <= size }
        invariant { forall ind. 0 <= ind < p.offset - arr.offset /\ select (at !mem 'Pre) (shift arr ind) = a -> select !mem (shift arr ind) = b }
        invariant { forall ind. 0 <= ind < p.offset - arr.offset /\ select (at !mem 'Pre) (shift arr ind) <> a -> select !mem (shift arr ind) = select (at !mem 'Pre) (shift arr ind)}
        invariant { forall ind. p.offset - arr.offset <= ind < size -> select !mem (shift arr ind) = select (at !mem 'Pre) (shift arr ind) }
        variant { size - (!p.offset - arr.offset) }
            if acc_safe !mem block_sizes !p = a then
                upd_safe mem block_sizes !p b;

            p := shift_safe !p 1;
        done;

end
